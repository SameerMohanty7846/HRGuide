Frontend:-
==========
=>While File uploading we should not use the simple form where we are sending json data
=>We should not only depend on the state variables for sending data to database
=>In postman we will send data via form data

=>In frontend do I need to mention something separately for sending data ?
yes but not on the form bt while sending data through api like this
      await axios.post("http://localhost:7007/api/users", formData, {
        headers: {
          "Content-Type": "multipart/form-data",//now we are sending the formData Object and  and which is sending file
        },
      });

const [form, setForm] = useState({ name: "", email: "", phone: "", file: null });

=>With only this we will not be able to upload files properly
=>we have to take predefined object formData 
      
      const formData = new FormData();
      formData.append("name", form.name);
      formData.append("email", form.email);
      formData.append("phone", form.phone);
      if (form.file) {
        formData.append("image", form.file); // 'image' matches multer field name on server
      }
=>We have to this kind of configuration for sending data through api

Full Code:-
-----------
import React, { useState, useEffect } from "react";
import axios from "axios";

const App = () => {
  const [form, setForm] = useState({ name: "", email: "", phone: "", file: null });
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Fetch users on mount
  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    try {
      const response = await axios.get("http://localhost:7007/api/users");
      setUsers(response.data.users);
    } catch (err) {
      console.error("Failed to fetch users", err);
      setError("Failed to fetch users");
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!form.name || !form.email || !form.phone) {
      alert("Please fill in all required fields");
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const formData = new FormData();
      formData.append("name", form.name);
      formData.append("email", form.email);
      formData.append("phone", form.phone);
      if (form.file) {
        formData.append("image", form.file); // 'image' matches multer field name on server
      }

      await axios.post("http://localhost:7007/api/users", formData, {
        headers: {
          "Content-Type": "multipart/form-data",
        },
      });

      alert("User registered successfully!");
      setForm({ name: "", email: "", phone: "", file: null });
      fetchUsers();
    } catch (err) {
      setError(err.response?.data?.message || "Error registering user");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ maxWidth: 600, margin: "2rem auto", fontFamily: "Arial, sans-serif" }}>
      <h2>Register User</h2>
      <form
        onSubmit={handleSubmit}
        style={{ marginBottom: "2rem", padding: "1rem", border: "1px solid #ccc", borderRadius: 5 }}
      >
        <input
          type="text"
          placeholder="Name"
          required
          value={form.name}
          onChange={(e) => setForm({ ...form, name: e.target.value })}
          style={{ width: "100%", padding: 8, marginBottom: 10 }}
        />
        <input
          type="email"
          placeholder="Email"
          required
          value={form.email}
          onChange={(e) => setForm({ ...form, email: e.target.value })}
          style={{ width: "100%", padding: 8, marginBottom: 10 }}
        />
        <input
          type="tel"
          placeholder="Phone"
          required
          value={form.phone}
          onChange={(e) => setForm({ ...form, phone: e.target.value })}
          style={{ width: "100%", padding: 8, marginBottom: 10 }}
        />
        <input
          type="file"
          accept="image/*"
          onChange={(e) => setForm({ ...form, file: e.target.files[0] })}
          style={{ width: "100%", marginBottom: 10 }}
        />
        <button type="submit" style={{ padding: "8px 16px" }} disabled={loading}>
          {loading ? "Submitting..." : "Submit"}
        </button>
        {error && <p style={{ color: "red", marginTop: 10 }}>{error}</p>}
      </form>

      <h2>Registered Users</h2>
      {users.length === 0 ? (
        <p>No users registered yet.</p>
      ) : (
        <table style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr>
              <th style={{ borderBottom: "1px solid #ddd", padding: 8 }}>Name</th>
              <th style={{ borderBottom: "1px solid #ddd", padding: 8 }}>Email</th>
              <th style={{ borderBottom: "1px solid #ddd", padding: 8 }}>Phone</th>
              <th style={{ borderBottom: "1px solid #ddd", padding: 8 }}>File</th>
            </tr>
          </thead>
          <tbody>
            {users.map((user) => (
              <tr key={user.id}>
                <td style={{ borderBottom: "1px solid #ddd", padding: 8 }}>{user.name}</td>
                <td style={{ borderBottom: "1px solid #ddd", padding: 8 }}>{user.email}</td>
                <td style={{ borderBottom: "1px solid #ddd", padding: 8 }}>{user.phone}</td>
                <td style={{ borderBottom: "1px solid #ddd", padding: 8 }}>
                  {user.fileName ? (
                    <a
                      href={`http://localhost:7007/uploads/${user.fileName}`}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      {user.fileName}
                    </a>
                  ) : (
                    "No file"
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
};

export default App;


Description of above:-
-----------------------
      const formData = new FormData();
      formData.append("name", form.name);
      formData.append("email", form.email);
      formData.append("phone", form.phone);
      if (form.file) {
        formData.append("image", form.file); // 'image' matches multer field name on server
      }

What is FormData?
FormData is a special JavaScript object designed for building key-value pairs that represent form fields,
especially useful when you want to send data including files (like images) over HTTP.

=>It encodes the data as multipart/form-data, which is the standard way to upload files and send form data 
in HTTP requests.

Handling the file:
=>if (form.file) checks if the user selected a file.
     If yes, it appends it to the form data as "image":
     formData.append("image", form.file);

Here:
"image" is the field name that the server (specifically multer middleware) expects for the file upload.
form.file is the actual file object (from <input type="file" />) selected by the user.
==============================================================================================================================
This is all about frontend now about  backend and middleware
============================================================
server.js
-----------
import express from 'express';
import { Sequelize, DataTypes } from 'sequelize';
import upload from './upload.js'; // ✅ Import multer middleware
import path from 'path';
import cors from 'cors';
const app = express();
const port = 7007;

// Middleware to parse JSON
app.use(express.json());
app.use(cors())
// ✅ Serve uploaded files

app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));
=>The above is just like an endpoint for accessing files 
                    http://localhost:7007/uploads/user1.jpg
=>
Part	                                         Meaning
'/uploads'	                           This is the URL endpoint (a route prefix). Clients will use this in the browser or in requests, e.g., http://localhost:7007/uploads/image.jpg
express.static(...)	                   This is the middleware that tells Express: “Serve files directly from this folder”
path.join(process.cwd(), 'uploads')	   This constructs the absolute file path to the physical folder on your server where the files (e.g. images) are stored


process.cwd():-
--------------
=>Returns the current working directory — basically, the folder where you started your Node.js process.
=>Example: If you start your server from /home/user/my-app, then process.cwd() returns /home/user/my-app.


path.join(process.cwd(), 'uploads'):-
-------------------------------------
What it does: Combines the current working directory path and the folder 'uploads' into one full absolute path string, in a way that works on all operating systems.
Example: If process.cwd() is /home/user/my-app, this results in /home/user/my-app/uploads.


// Database connection
const sequelize = new Sequelize('db', 'root', '', {
  host: 'localhost',
  dialect: 'mysql',
  logging: false,
});

// Test DB connection
sequelize.authenticate()
  .then(() => {
    console.log('Database connected successfully.');
  })
  .catch((err) => {
    console.error('Unable to connect to the database:', err);
  });

// Define User model
const User = sequelize.define('User', {
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false
  },
  phone: {
    type: DataTypes.STRING,
    allowNull: false
  },
  fileName: {
    type: DataTypes.STRING,
    allowNull: true
  }
}, {
  tableName: 'users',
  timestamps: false
});

// Sync model
sequelize.sync();

// ========== CONTROLLERS ==========

// Register a new user (with file upload)
const registerUser = async (req, res) => {
  const { name, email, phone } = req.body;
  const fileName = req.file ? req.file.filename : null;//do it after middleware
  Multer parses the incoming request, and if a file was uploaded under the field name image, it attaches the file data to req.file.

So req.file becomes an object like:

{
  fieldname: 'image',
  originalname: 'myphoto.jpg',
  encoding: '7bit',
  mimetype: 'image/jpeg',
  destination: 'uploads/',
  filename: '1692982889012-myphoto.jpg',
  path: 'uploads/1692982889012-myphoto.jpg',
  size: 102342
}


If no file was uploaded, req.file will be undefined.

  if (!name || !email || !phone) {
    return res.status(400).json({ message: 'Name, email, and phone are required' });
  }

  try {
    const user = await User.create({ name, email, phone, fileName });
    res.status(201).json({ message: 'User registered successfully', user });
  } catch (error) {
    console.error('Error registering user:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

// Get all users
const getAllUsers = async (req, res) => {
  try {
    const users = await User.findAll();
    res.status(200).json({ users });
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

// ========== ROUTES ==========

app.get('/', (req, res) => {
  res.send('Server is running');
});

// ✅ Use multer middleware for file upload
app.post('/api/users', upload.single('image'), registerUser);
app.get('/api/users', getAllUsers);

// ========== START SERVER ==========

app.listen(port, () => {
  console.log(`Server started at http://localhost:${port}`);
});

export default sequelize;


Middleware:
------------
// upload.js

import multer from 'multer';
import path from 'path';
import fs from 'fs';

// Set the uploads directory==>Specifying the location to upload
const uploadDir = path.join(process.cwd(), 'uploads');

// Ensure it exist==>checks whether the folder exists or not if not create it 
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

//{ recursive: true } means:
    If parent folders don’t exist, create them too.
    Prevents errors if parts of the path are missing.

// Configure storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {//select the directory where to store 
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {//the work of this is to  give separate unique  names for the files 
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
    const ext = path.extname(file.originalname);//get the extension
    const baseName = path.basename(file.originalname, ext);
    cb(null, `${baseName}-${uniqueSuffix}${ext}`);
  },
});

// File filter: allow only images
const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);

  if (mimetype && extname) {
    cb(null, true);
  } else {
    cb(new Error('Only image files are allowed!'));
  }
};

// Export the multer middleware (single file field: 'image')
const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
});

export default upload;

Other Multer Methods
=>Multer provides other methods for different upload scenarios:

Method	Use Case
.single(fieldname)	                                One file from one field
.array(fieldname, maxCount)          	              Multiple files from the same field
.fields([{ name: 'field1' }, { name: 'field2' }])  	Multiple fields, each with one or more files
.any()                                             	Accepts files from any field (less controlled)