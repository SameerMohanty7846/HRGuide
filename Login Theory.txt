Login Theory Backend
=======================
import express from "express";
import cookieParser from "cookie-parser";
import jwt from "jsonwebtoken";

const app = express();
app.use(express.json());
app.use(cookieParser());

const SECRET_KEY = "mysecretkey"; // In production, keep this in env vars

// 1️⃣ Login Endpoint
app.post("/login", (req, res) => {
  const { email, password } = req.body;

  // Dummy check (normally you'd check DB)
  if (email === "user@example.com" && password === "mypassword") {
    // Create a JWT token
    const token = jwt.sign({ email }, SECRET_KEY, { expiresIn: "1h" });

    // Store token in HttpOnly cookie
    res.cookie("authToken", token, {//authToken is the cookie name 
      httpOnly: true,   // Not accessible via JS
      secure: false,    // true in production (HTTPS only)
      sameSite: "strict"
    });

    return res.json({ message: "Login successful" });
  } else {
    return res.status(401).json({ message: "Invalid credentials" });
  }
});

// Middleware to check cookie
function authMiddleware(req, res, next) {
  const token = req.cookies.authToken;//Without cookie-parser, req.cookies would be undefined, and this line would not work.
  if (!token) {
    return res.status(401).json({ message: "No token, unauthorized" });
  }

  try {
    const decoded = jwt.verify(token, SECRET_KEY);//If valid → decoded contains the payload
    req.user = decoded; // attach user info
    next();
  } catch (err) {
    return res.status(401).json({ message: "Invalid or expired token" });
  }
}

// 2️⃣ Protected Route
app.get("/user", authMiddleware, (req, res) => {
  res.json({
    message: "User info retrieved",
    user: { email: req.user.email, name: "John Doe" } // Dummy data
  });
});

app.listen(5000, () => {
  console.log("Server running on http://localhost:5000");
});


SOME INFORMATION ABOUT COOKIES-
------------------------------
=>It should be sent with the login api as well
=>withCredentials: true during login is like:
Telling the browser, “Hey, please be ready to accept and store any cookies that come back with this response.”

FLOW WITH THE COOKIES:-
-----------------------
=>Ok I will be getting the cookies from the backend so how to deal further with the cookies in frontend 
=>
=============================================

import User from '../models/User.js';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

import User from '../models/User.js';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export const register = async (req, res) => {
  try {
    const { name, email, mobile, profilePic } = req.body;

    // Validate required fields (no password here)
    if (!name || !email || !mobile || !profilePic) {
      return res.status(400).json({ error: 'All fields are required.' });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ where: { email } });
    if (existingUser) {
      return res.status(409).json({ error: 'Email already exists.' });
    }

    const existingMobile = await User.findOne({ where: { mobile } });
    if (existingMobile) {
      return res.status(409).json({ error: 'Mobile number already exists.' });
    }

    // Dynamically create password as email + '123'
    const rawPassword = `${email}123`;

    // Hash password
    const hashedPassword = await bcrypt.hash(rawPassword, 10);

    // Create new admin user
    const newUser = await User.create({
      name,
      email,
      mobile,
      password: hashedPassword,
      profilePic,
      isAdmin: false,
    });

    return res.status(201).json({
      message: 'User registered successfully.',
      admin: {
        id: newUser.id,
        name: newUser.name,
        email: newUser.email,
        mobile: newUser.mobile,
        isAdmin: newUser.isAdmin,
      },
    });

  } catch (error) {
    console.error('Signup error:', error);
    return res.status(500).json({ error: 'Internal server error.' });
  }
};

export const login = async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required.' });
    }

    const user = await User.findOne({ where: { email } });

    if (!user) {
      return res.status(404).json({ error: 'Admin not found.' });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(401).json({ error: 'Invalid password.' });
    }

    if (!process.env.JWT_SECRET) {
      console.error('JWT_SECRET is NOT defined!');
      return res.status(500).json({ error: 'JWT_SECRET environment variable not set' });
    }

    const payload = {
      id: user.id,
      email: user.email,
      isAdmin: user.isAdmin,
    };

    // Use process.env.JWT_SECRET directly here
    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1d' });

    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000,
    });

    return res.status(200).json({
      message: 'Login successful.',
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        mobile: user.mobile,
        isAdmin: user.isAdmin,
      },
    });

  } catch (error) {
    console.error('Login error:', error);
    return res.status(500).json({ error: 'Internal server error.' });
  }
};

export const getAllUsers = async (req, res) => {
  try {
    const users = await User.findAll({
      attributes: ['id', 'name', 'email', 'mobile', 'profilePic', 'isActive'],
    });

    return res.status(200).json({
      message: 'Users fetched successfully.',
      users,
    });
  } catch (error) {
    console.error('Get all users error:', error);
    return res.status(500).json({ error: 'Internal server error.' });
  }
};
export const getLoggedInUser = (req, res) => {
  try {
    // req.user is set by authMiddleware if token is valid
    if (!req.user) {
      return res.status(401).json({ message: 'Unauthorized' });
    }

    // Return user info (from JWT payload)
    res.status(200).json({ user: req.user });
  } catch (error) {
    console.error('Get logged-in user error:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const logout = (req, res) => {
  res.clearCookie('token', {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
  });

  return res.status(200).json({ message: 'Logout successful.' });
};


//Middleware
import jwt from 'jsonwebtoken'
export default function authMiddleware(req, res, next) {
  const token = req.cookies.token;//Without cookie-parser, req.cookies would be undefined, and this line would not work.
  if (!token) {
    return res.status(401).json({ message: "No token, unauthorized" });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);//If valid → decoded contains the payload
    req.user = decoded; // attach user info
    next();
  } catch (err) {
    return res.status(401).json({ message: "Invalid or expired token" });
  }
}
===================================================
Frontend - Private or Protected Route not used in a different way
import React, { useState,useEffect } from 'react';
import axios from 'axios';
import AuthContext from './AuthContext'; // ✅ Make sure this filename is correct and matches the actual file
import { useNavigate } from 'react-router-dom';

const AuthState = ({ children }) => {
  const navigate = useNavigate()
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Automatically fetch user session on page refresh
  const fetchUser = async () => {
    try {
      const res = await axios.get('http://localhost:7777/admin/me', {
        withCredentials: true,
      });
      setUser(res.data.user);
    } catch (err) {
      setUser(null);
    } finally {
      setLoading(false);
    }
  };

  // Fetch user once when component mounts
  useEffect(() => {
    fetchUser();
  }, []);



  // ✅ Login function
  const login = async ({ email, password }) => {
    setLoading(true);
    setError(null);

    try {
      const response = await axios.post(
        "http://localhost:7777/admin/login",
        { email, password },
        { withCredentials: true }
      );

      setUser(response.data.user);
      setLoading(false);
      return true;
    } catch (err) {
      setError(err.response?.data?.error || 'Login failed');
      setLoading(false);
      return false;
    }
  };
useEffect(() => {
  if (!loading && !user) {
    navigate('/login');
  }
}, [user, loading, navigate]);



  // Logout function
   const logout = async () => {
    try {
      await axios.post('http://localhost:7777/admin/logout', {}, { withCredentials: true });
    } catch (err) {
      console.error('Logout failed:', err);
    }
    setUser(null);
    navigate('/login'); // Redirect after logout
  };



  return (
    <AuthContext.Provider
      value={{
        user,
        setUser,
        loading,
        setLoading,
        error,
        setError,
        login,
        logout
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export default AuthState;
=================================
import React, { useContext, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import AuthContext from '../../context/AuthContext';

const NonAuthLayout = ({ children }) => {
  const { user, loading } = useContext(AuthContext);
  const navigate = useNavigate();

  useEffect(() => {
    if (!loading && user) {
      // If user is logged in, redirect to dashboard
      navigate(-1);
    }
  }, [user, loading, navigate]);

  // Show nothing or a loader while checking auth
  if (loading) {
    return <div>Loading...</div>;
  }

  // If not logged in, allow access to login/register/etc.
  return <>{children}</>;
};

export default NonAuthLayout;
===================================
For Logout:-
------------
const handleLogout = () => {
        profileDropdownClose();
        logout()
        // localStorage.clear();
        navigate('/login');
};
====================================
Login.jsx:-
------------
import React, { useState,useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { FcGoogle } from "react-icons/fc";
import { RiFacebookCircleFill } from "react-icons/ri";
import Tostify from "../Common/Tostify";
import { toast } from "react-toastify";
import lgnIllustrator from "../../Assets/Login/lgnIll.png";
import logo from "../../Assets/Logos/logo.jpg";
import lgnBg from "../../Assets/Logos/LoginBanner.jpg";
import LeftSection from "../../Components/Login/LeftSection";
import axios from "axios";
import { useContext } from "react";
import AuthContext from "../../context/AuthContext";

const Login = () => {
  const { user, setUser, loading, setLoading, error, setError, login } = useContext(AuthContext);
  const navigate = useNavigate();

  const [formData, setFormData] = useState({
    email: '',
    password: '',

  })

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value
    }))
  }



  const handleLogin = async (e) => {
    e.preventDefault(); // prevent default form submit behavior

    try {
      // const response = await axios.post(
      //   "http://localhost:7777/admin/login",
      //   formData,
      //    { withCredentials: true }
      // );

      const status = await login(formData);

     

      if (status) {
        alert('Logged in Successfully')
        navigate("/admin/dashboard");


      } else {
        alert('Failed to login')
        navigate("/login");

      }

    } catch (error) {
      alert("Login failed. Please try again.");

    }
  };
  useEffect(() => {
  if (user) {
    console.log("✅ User updated in Login component:", user);
  }
  }, [user]);

  const goToSignUP = () => {
    navigate("/sign-up");
  };

  const tostifyErr = (msg) => {
    toast.error(msg, {
      position: "top-center",
      autoClose: 3000,
      hideProgressBar: false,
      closeOnClick: true,
      pauseOnHover: true,
      draggable: true,
      progress: undefined,
      theme: "colored",
    });
  };

  return (
    <div className="min-h-screen grid grid-cols-1 md:grid-cols-2">
      {/* Left Side */}
      <LeftSection logo={logo} />

      {/* Right Side */}
      <div
        className="flex justify-center items-center p-10 bg-cover bg-center"
        style={{ backgroundImage: `url(${lgnBg})` }}
      >
        <div className="bg-white rounded-xl shadow-lg p-8 w-full max-w-md">
          <h2 className="text-xl font-semibold mb-1">Welcome to our CRM</h2>
          <h3 className="text-2xl font-bold mb-4">Log In Now</h3>
          <p className="text-gray-500 mb-6">
            Enter your details to proceed further
          </p>
          <form onSubmit={handleLogin} className="space-y-4">
            <div>
              <input
                type="email"
                placeholder="Email"
                className="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400"
                name="email"
                value={formData.email}
                onChange={handleChange}
              />
            </div>
            <div>
              <input
                type="password"
                placeholder="Password"
                className="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400"
                name="password"
                value={formData.password}
                onChange={handleChange}
              />
            </div>
            <div className="flex items-center">
              <input type="checkbox" id="remember" className="mr-2" />
              <label htmlFor="remember" className="text-sm text-gray-700">
                Remember Me !
              </label>
            </div>
            <button
              type="submit"
              className="w-full bg-primary text-white py-2 rounded-md hover:bg-btnHover transition duration-200"
            >
              Log in
            </button>
          </form>
        </div>
      </div>
    </div>
  );
};

export default Login;

import React, { useContext, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import AuthContext from '../../context/AuthContext';

const NonAuthLayout = ({ children }) => {
  const { user, loading } = useContext(AuthContext);
  const navigate = useNavigate();

  useEffect(() => {
    if (!loading && user) {
       // If user is logged in, redirect to dashboard
      navigate(-1);
    }
  }, [user, loading, navigate]);

  // Show nothing or a loader while checking auth
  if (loading) {
    return <div>Loading...</div>;
  }

  // If not logged in, allow access to login/register/etc.
  return <>{children}</>;
};

export default NonAuthLayout;














