Login Theory Backend
=======================
import express from "express";
import cookieParser from "cookie-parser";
import jwt from "jsonwebtoken";

const app = express();
app.use(express.json());
app.use(cookieParser());

const SECRET_KEY = "mysecretkey"; // In production, keep this in env vars

// 1️⃣ Login Endpoint
app.post("/login", (req, res) => {
  const { email, password } = req.body;

  // Dummy check (normally you'd check DB)
  if (email === "user@example.com" && password === "mypassword") {
    // Create a JWT token
    const token = jwt.sign({ email }, SECRET_KEY, { expiresIn: "1h" });

    // Store token in HttpOnly cookie
    res.cookie("authToken", token, {//authToken is the cookie name 
      httpOnly: true,   // Not accessible via JS
      secure: false,    // true in production (HTTPS only)
      sameSite: "strict"
    });

    return res.json({ message: "Login successful" });
  } else {
    return res.status(401).json({ message: "Invalid credentials" });
  }
});

// Middleware to check cookie
function authMiddleware(req, res, next) {
  const token = req.cookies.authToken;//Without cookie-parser, req.cookies would be undefined, and this line would not work.
  if (!token) {
    return res.status(401).json({ message: "No token, unauthorized" });
  }

  try {
    const decoded = jwt.verify(token, SECRET_KEY);//If valid → decoded contains the payload
    req.user = decoded; // attach user info
    next();
  } catch (err) {
    return res.status(401).json({ message: "Invalid or expired token" });
  }
}

// 2️⃣ Protected Route
app.get("/user", authMiddleware, (req, res) => {
  res.json({
    message: "User info retrieved",
    user: { email: req.user.email, name: "John Doe" } // Dummy data
  });
});

app.listen(5000, () => {
  console.log("Server running on http://localhost:5000");
});


SOME INFORMATION ABOUT COOKIES-
------------------------------
=>It should be sent with the login api as well
=>withCredentials: true during login is like:
Telling the browser, “Hey, please be ready to accept and store any cookies that come back with this response.”

FLOW WITH THE COOKIES:-
-----------------------
=>Ok I will be getting the cookies from the backend so how to deal further with the cookies in frontend 
=>
=============================================

import User from '../models/User.js';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export const register = async (req, res) => {
  try {
    const { name, email, mobile, profilePic } = req.body;

    // Validate required fields (no password here)
    if (!name || !email || !mobile || !profilePic) {
      return res.status(400).json({ error: 'All fields are required.' });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ where: { email } });
    if (existingUser) {
      return res.status(409).json({ error: 'Email already exists.' });
    }

    const existingMobile = await User.findOne({ where: { mobile } });
    if (existingMobile) {
      return res.status(409).json({ error: 'Mobile number already exists.' });
    }

    // Dynamically create password as email + '123'
    const rawPassword = `${email}123`;

    // Hash password
    const hashedPassword = await bcrypt.hash(rawPassword, 10);

    // Create new admin user
    const newUser = await User.create({
      name,
      email,
      mobile,
      password: hashedPassword,
      profilePic,
      isAdmin: false,
    });

    return res.status(201).json({
      message: 'User registered successfully.',
      admin: {
        id: newUser.id,
        name: newUser.name,
        email: newUser.email,
        mobile: newUser.mobile,
        isAdmin: newUser.isAdmin,
      },
    });

  } catch (error) {
    console.error('Signup error:', error);
    return res.status(500).json({ error: 'Internal server error.' });
  }
};

export const login = async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required.' });
    }

    const user = await User.findOne({ where: { email } });

    if (!user) {
      return res.status(404).json({ error: 'Admin not found.' });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(401).json({ error: 'Invalid password.' });
    }

    if (!process.env.JWT_SECRET) {
      console.error('JWT_SECRET is NOT defined!');
      return res.status(500).json({ error: 'JWT_SECRET environment variable not set' });
    }

    const payload = {
      id: user.id,
      email: user.email,
      isAdmin: user.isAdmin,
    };

    // Use process.env.JWT_SECRET directly here
    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1d' });

    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000,
    });

    return res.status(200).json({
      message: 'Login successful.',
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        mobile: user.mobile,
        isAdmin: user.isAdmin,
      },
    });

  } catch (error) {
    console.error('Login error:', error);
    return res.status(500).json({ error: 'Internal server error.' });
  }
};

export const getAllUsers = async (req, res) => {
  try {
    const users = await User.findAll({
      attributes: ['id', 'name', 'email', 'mobile', 'profilePic', 'isActive'],
    });

    return res.status(200).json({
      message: 'Users fetched successfully.',
      users,
    });
  } catch (error) {
    console.error('Get all users error:', error);
    return res.status(500).json({ error: 'Internal server error.' });
  }
};
export const getLoggedInUser = (req, res) => {
  try {
    // req.user is set by authMiddleware if token is valid
    if (!req.user) {
      return res.status(401).json({ message: 'Unauthorized' });
    }

    // Return user info (from JWT payload)
    res.status(200).json({ user: req.user });
  } catch (error) {
    console.error('Get logged-in user error:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};















